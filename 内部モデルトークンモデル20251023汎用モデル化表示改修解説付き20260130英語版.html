<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ishida Model (Internal Morphogenesis) - Generalized v5.0 (Regeneration Study) - English Ver.</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: sans-serif;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap; /* Wrap if screen width is insufficient */
        }
        canvas {
            border: 1px solid #ccc;
            background-color: #fff;
            cursor: pointer;
        }
        /* Common styles for control panel and stats display area */
        .controls, #stats-display {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 350px;
            align-self: flex-start; /* Align to the top */
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .control-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .control-group label {
            font-weight: bold;
            font-size: 0.9em;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex-grow: 1; /* Slider takes up available width */
        }
        input[type="button"] {
            padding: 8px 15px;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            flex-grow: 1;
        }
        input[type="button"]:hover {
            background-color: #0056b3;
        }
        input[type="button"].danger { /* Button for dangerous operations (e.g., clearing data) */
            background-color: #dc3545;
        }
        input[type="button"].danger:hover {
            background-color: #c82333;
        }
        input[type="number"] {
            width: 80px;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .param-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        .param-value { /* Style to display current parameter value */
            font-family: monospace;
            min-width: 40px;
            text-align: right;
        }
        .radio-label {
            font-weight: normal;
            font-size: 0.9em;
        }
        /* Token model specific parameters (hidden by default) */
        .token-model-params {
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 5px;
            padding-left: 10px;
            border-left: 3px solid #007bff;
            margin-top: 5px;
        }
        
        /* Stats display area styles */
        #stats-display h3 {
            margin: 0 0 10px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #007bff;
            text-align: center;
        }
        .stats-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .stats-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.95em;
        }
        .stats-item .label {
            font-weight: bold;
            color: #555;
        }
        .stats-item .value {
            font-family: monospace;
            font-weight: bold;
            font-size: 1.05em;
            color: #000;
            min-width: 80px;
            text-align: right;
        }
        
    </style>
</head>
<body>

    <canvas id="lifegame"></canvas>

    <div id="stats-display">
        <h3>Simulation Stats</h3>
        
        <div class="control-group">
            <div class="stats-group">
                <div class="stats-item">
                    <span class="label">Time Step:</span>
                    <span class="value" id="stats-timestep">0</span>
                </div>
                <div class="stats-item">
                    <span class="label">Active Cells (Area):</span>
                    <span class="value" id="stats-active-cells">0</span>
                </div>
                <div class="stats-item">
                    <span class="label">Boundary Cells (Perimeter):</span>
                    <span class="value" id="stats-boundary-cells">0</span>
                </div>
            </div>
        </div>

        <div class="control-group">
            <label>Internal State (Potential)</label>
            <div class="stats-group">
                <div class="stats-item">
                    <span class="label">Average:</span>
                    <span class="value" id="stats-potential-avg">0.000</span>
                </div>
                <div class="stats-item">
                    <span class="label">Max:</span>
                    <span class="value" id="stats-potential-max">0.000</span>
                </div>
                <div class="stats-item">
                    <span class="label">Min:</span>
                    <span class="value" id="stats-potential-min">0.000</span>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label>Morphology</label>
            <div class="stats-group">
                <div class="stats-item">
                    <span class="label">Circularity:</span>
                    <span class="value" id="stats-circularity">0.000</span>
                </div>
                <div class="stats-item">
                    <span class="label">Dispersion:</span>
                    <span class="value" id="stats-dispersion">0.000</span>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <div class="control-row">
                <input type="button" value="Set Initial Circle" id="buttonRandom">
                <input type="button" value="Start" id="buttonStart">
                <input type="button" value="Reset" id="buttonReset">
            </div>
            <div class="control-row">
                 <input type="button" value="View Potential" id="buttonView">
            </div>
        </div>
        
        <div class="control-group">
            <label>Data Save Settings</label>
            <div class="control-row">
                <label for="saveTimeStepInput" class="radio-label">Save Data Step:</label>
                <input type="number" id="saveTimeStepInput" value="1000" min="0" step="100">
            </div>
            <div class="control-row">
                <label for="imageSaveIntervalInput" class="radio-label">Image Save Interval:</label>
                <input type="number" id="imageSaveIntervalInput" value="100" min="0" step="10">
            </div>
             <div class="control-row">
                <input type="button" value="Clear Saved Data" id="clearDataButton" class="danger">
            </div>
        </div>

        <div class="control-group">
            <label>Token Distribution Model</label>
            <div>
                <input type="radio" id="tokenModel1" name="tokenModel" value="1" checked>
                <label for="tokenModel1" class="radio-label">1: Equal Dist (Current)</label>
                </div>
            <div>
                <input type="radio" id="tokenModel2" name="tokenModel" value="2">
                <label for="tokenModel2" class="radio-label">2: Equal Dist (With Carryover)</label>
                <div id="tokenModel2Params" class="token-model-params">
                    <label for="carryOverRateSlider">Carryover Rate: <span id="carryOverRateValue" class="param-value">0.50</span></label>
                    <input type="range" id="carryOverRateSlider" min="0.0" max="1.0" step="0.01" value="0.5">
                </div>
            </div>
            <div>
                <input type="radio" id="tokenModel3" name="tokenModel" value="3">
                <label for="tokenModel3" class="radio-label">3: Equal Dist (Regeneration Study)</label>
                </div>
        </div>
        
        <div class="control-group">
            <label>Cell Update Rule</label>
            <div>
                <input type="radio" id="ruleModel1" name="updateRule" value="1" checked>
                <label for="ruleModel1" class="radio-label">1: Boundary Only</label>
            </div>
            <div>
                <input type="radio" id="ruleModel2" name="updateRule" value="2">
                <label for="ruleModel2" class="radio-label">2: Internal & Boundary</label>
            </div>
        </div>
        
        <div class="control-group">
            <label>Potential Formula (P)</label>
            <div>
                <input type="radio" id="formula1" name="potentialFormula" value="1" checked>
                <label for="formula1" class="radio-label">Formula 1: P = (1-X) - (1-Y) * w</label>
            </div>
            <div>
                <input type="radio" id="formula2" name="potentialFormula" value="2">
                <label for="formula2" class="radio-label">Formula 2: P = (1-Y) - (1-X) * w</label>
            </div>
        </div>

        <div id="sliders-container">
            <div class="control-group">
                <label for="zSlider">Token Steps (Z): <span id="zValue" class="param-value">20</span></label>
                <input type="range" id="zSlider" min="5" max="40" step="1" value="20">
            </div>
            <div class="control-group">
                <label for="xSlider">Range X (1-X): <span id="xValue" class="param-value">8</span></label>
                <input type="range" id="xSlider" min="1" max="38" step="1" value="8">
            </div>
            <div class="control-group">
                <label for="ySlider">Range Y (1-Y): <span id="yValue" class="param-value">16</span></label>
                <input type="range" id="ySlider" min="2" max="39" step="1" value="16">
            </div>
            <div class="control-group">
                <label for="wSlider">w: <span id="wValue" class="param-value">0.470</span></label>
                <input type="range" id="wSlider" min="0.1" max="1.0" step="0.001" value="0.470">
            </div>
            <div class="control-group">
                <label for="r1Slider">r1 (Outer): <span id="r1Value" class="param-value">24</span></label>
                <input type="range" id="r1Slider" min="2" max="40" step="1" value="24">
            </div>
            <div class="control-group">
                <label for="r2Slider">r2 (Inner): <span id="r2Value" class="param-value">12</span></label>
                <input type="range" id="r2Slider" min="1" max="39" step="1" value="12">
            </div>
             <div class="control-group">
                <label for="gSlider">Growth Threshold (G): <span id="gValue" class="param-value">1.40</span></label>
                <input type="range" id="gSlider" min="-2.0" max="2.0" step="0.01" value="1.40">
            </div>
            <div class="control-group">
                <label for="rSurvivalSlider">Survival Threshold (R_survival): <span id="rSurvivalValue" class="param-value">1.27</span></label>
                <input type="range" id="rSurvivalSlider" min="-2.0" max="2.0" step="0.01" value="1.27">
            </div>
            <div class="control-group">
                <label for="rOvercrowdSlider">Overcrowd Threshold (R_overcrowd): <span id="rOvercrowdValue" class="param-value">50</span></label>
                <input type="range" id="rOvercrowdSlider" min="-10.0" max="50.0" step="0.01" value="50">
            </div>
        </div>
    </div>

<script>
/*
 * =======================================================================
 * Ishida Model (Internal Morphogenesis) - Generalized v5.0
 * -----------------------------------------------------------------------
 * - v4.1: Modified logic for tokenModelMode 3 (Cellular Robot type).
 * - v5.0: 
 * - Reorganized model selection (1: Current, 2: With Carryover, 3: Regeneration Study)
 * - Modified to save data even when all cells die in state 1
 * - Modified not to reset time step when stopping (Resume possible)
 * - Added function to save potential image simultaneously at final save
 * =======================================================================
 */


/*
 * -----------------------------------------------------------------------
 * ðŸ§¬ 1. Global Structure and Variables
 * -----------------------------------------------------------------------
 * Define variables used throughout the simulation.
 */

// --- Drawing Related ---
var canvas, ctx; // canvas element and drawing context
var cellSize = 5; // Pixel size of one cell
var meshNum = 150; // Number of cells per grid side (150x150)

// --- Cell State Arrays ---
// Accessed as [i][j] (or [x][y]) 2D arrays
var cells = []; // Cell state (state_on: 1 / state_off: 0)
var potential = []; // Potential value of each cell
var cells_w = []; // Parameter 'w' for each cell (currently unified global value)
var cells_r1 = []; // Parameter 'r1' for each cell (currently unused)
var cells_r2 = []; // Parameter 'r2' for each cell (currently unused)
var cells_x = []; // Drawing X coordinate for each cell
var cells_y = []; // Drawing Y coordinate for each cell

// --- Token Related ---
var globalTotalTokens = []; // 3D array holding token info [x][y][v]
                           // Used in tokenModelMode 2 (With Carryover)
const MAX_TOKEN_VALUE_GLOBAL = 52; // Max token steps (v) + reserve

// --- Simulation Control ---
var timer1; // Simulation interval timer
var running = false; // Simulation running flag
var viewMode = 'state'; // View mode ('state': Cell state, 'potential': Potential value)

// --- Model Selection Modes ---
var potentialFormulaMode = 1; // Potential formula (1 or 2)
var tokenModelMode = 1; // Token distribution model (1, 2, 3) 
                        // 1: Equal Dist (Current), 2: With Carryover, 3: Regeneration Study
var updateRuleMode = 1; // Cell update rule (1: Boundary Only, 2: Internal & Boundary)

// --- Parameter Defaults (Initial UI Slider Values) ---
var w_base = 0.470;
var r1_base = 24;
var r2_base = 12;
var g_threshold_base = 1.40;
var Z_base = 20; // Token propagation steps
var X_base = 8; // Potential calculation range X (1~X)
var Y_base = 16; // Potential calculation range Y (1~Y)
var R_survival_base = 1.27; // Survival lower threshold
var R_overcrowd_base = 50.0; // Overcrowding (death) upper threshold
var carryOverRate_base = 0.5; // Model 2: Carryover rate

// --- Cell State Definitions ---
var state_on = 1; // Cell "ON" (Alive) state
var state_off = 0; // Cell "OFF" (Dead) state

// --- Stats & Data Saving Related ---
var timeStep = 0; // Current simulation time step
// DOM elements for stats display
var statsTimeStepEl, statsActiveCellsEl, statsBoundaryCellsEl;
var statsPotentialAvgEl, statsPotentialMaxEl, statsPotentialMinEl;
var statsCircularityEl, statsDispersionEl;

var timeSeriesData = []; // Array to store time-series data
var saveTimeStep = 1000; // Save CSV etc. when this step is reached
var imageSaveInterval = 100; // Save image at this interval
var saveTimeStepInput, imageSaveIntervalInput, clearDataButton; // Data save settings UI

// --- UI Element Variables ---
var buttonStart, buttonRandom, buttonReset, buttonView;
var wSlider, r1Slider, r2Slider, gSlider;
var wValue, r1Value, r2Value, gValue;
var zSlider, xSlider, ySlider, rSurvivalSlider, rOvercrowdSlider;
var zValue, xValue, yValue, rSurvivalValue, rOvercrowdValue;
var formula1Radio, formula2Radio;
var tokenModel1Radio, tokenModel2Radio, tokenModel3Radio;
var tokenModel2Params; // Display area for model-specific parameters
var carryOverRateSlider;
var carryOverRateValue;
var ruleModel1Radio, ruleModel2Radio;


/*
 * -----------------------------------------------------------------------
 * ðŸŽ¨ 2. Initialization and UI Event Processing
 * -----------------------------------------------------------------------
 */

/**
 * Main initialization function executed when the page finishes loading
 */
window.onload = function() {
    canvas = document.getElementById('lifegame');
    ctx = canvas.getContext('2d');
    getUIElements(); // Get UI elements from HTML
    addEventListeners(); // Register event listeners (clicks, etc.) to UI elements
    initCells(); // Initialize cell arrays and canvas
    updateParameters(); // Reflect slider initial values to parameters
    updateTokenModelMode(); // Reflect selected token model
    resetStatsDisplay(); // Reset stats display
};

/**
 * Get DOM elements to be manipulated from HTML and store in global variables
 */
function getUIElements() {
    // Buttons
    buttonStart = document.getElementById('buttonStart');
    buttonRandom = document.getElementById('buttonRandom');
    buttonReset = document.getElementById('buttonReset');
    buttonView = document.getElementById('buttonView');
    
    // Sliders and Value Displays
    wSlider = document.getElementById('wSlider');
    r1Slider = document.getElementById('r1Slider');
    r2Slider = document.getElementById('r2Slider');
    gSlider = document.getElementById('gSlider');
    wValue = document.getElementById('wValue');
    r1Value = document.getElementById('r1Value');
    r2Value = document.getElementById('r2Value');
    gValue = document.getElementById('gValue');
    zSlider = document.getElementById('zSlider');
    xSlider = document.getElementById('xSlider');
    ySlider = document.getElementById('ySlider');
    rSurvivalSlider = document.getElementById('rSurvivalSlider');
    rOvercrowdSlider = document.getElementById('rOvercrowdSlider');
    zValue = document.getElementById('zValue');
    xValue = document.getElementById('xValue');
    yValue = document.getElementById('yValue');
    rSurvivalValue = document.getElementById('rSurvivalValue');
    rOvercrowdValue = document.getElementById('rOvercrowdValue');
    
    // Radio Buttons (Formula)
    formula1Radio = document.getElementById('formula1');
    formula2Radio = document.getElementById('formula2');

    // Radio Buttons (Token Model)
    tokenModel1Radio = document.getElementById('tokenModel1');
    tokenModel2Radio = document.getElementById('tokenModel2');
    tokenModel3Radio = document.getElementById('tokenModel3');
    
    // Token Model Specific Parameter UI
    tokenModel2Params = document.getElementById('tokenModel2Params');
    carryOverRateSlider = document.getElementById('carryOverRateSlider');
    carryOverRateValue = document.getElementById('carryOverRateValue');

    // Radio Buttons (Update Rule)
    ruleModel1Radio = document.getElementById('ruleModel1');
    ruleModel2Radio = document.getElementById('ruleModel2');

    // Stats Display
    statsTimeStepEl = document.getElementById('stats-timestep');
    statsActiveCellsEl = document.getElementById('stats-active-cells');
    statsBoundaryCellsEl = document.getElementById('stats-boundary-cells');
    statsPotentialAvgEl = document.getElementById('stats-potential-avg');
    statsPotentialMaxEl = document.getElementById('stats-potential-max');
    statsPotentialMinEl = document.getElementById('stats-potential-min');
    statsCircularityEl = document.getElementById('stats-circularity');
    statsDispersionEl = document.getElementById('stats-dispersion');
    
    // Data Save Settings
    saveTimeStepInput = document.getElementById('saveTimeStepInput');
    imageSaveIntervalInput = document.getElementById('imageSaveIntervalInput');
    clearDataButton = document.getElementById('clearDataButton');
}

/**
 * Register event listeners for each UI element
 */
function addEventListeners() {
    // Button click events
    buttonStart.addEventListener('click', onStart, false);
    buttonRandom.addEventListener('click', randomCells, false);
    buttonReset.addEventListener('click', initCells, false);
    buttonView.addEventListener('click', toggleView, false);
    canvas.addEventListener('click', canvasClick, false); // Toggle cell on canvas click

    // Slider input events (fired whenever value changes)
    wSlider.addEventListener('input', updateParameters);
    r1Slider.addEventListener('input', updateParameters);
    r2Slider.addEventListener('input', updateParameters);
    gSlider.addEventListener('input', updateParameters);
    zSlider.addEventListener('input', updateParameters);
    xSlider.addEventListener('input', updateParameters);
    ySlider.addEventListener('input', updateParameters);
    rSurvivalSlider.addEventListener('input', updateParameters);
    rOvercrowdSlider.addEventListener('input', updateParameters);
    
    // Radio button change events
    formula1Radio.addEventListener('change', updateFormulaMode);
    formula2Radio.addEventListener('change', updateFormulaMode);

    tokenModel1Radio.addEventListener('change', updateTokenModelMode);
    tokenModel2Radio.addEventListener('change', updateTokenModelMode);
    tokenModel3Radio.addEventListener('change', updateTokenModelMode);
    
    // Token model specific slider events
    carryOverRateSlider.addEventListener('input', updateParameters);

    ruleModel1Radio.addEventListener('change', updateRuleModelMode);
    ruleModel2Radio.addEventListener('change', updateRuleModelMode);
    
    // Data save settings change events
    saveTimeStepInput.addEventListener('input', updateParameters);
    imageSaveIntervalInput.addEventListener('input', updateParameters);
    clearDataButton.addEventListener('click', () => {
        timeSeriesData = []; // Empty time-series data
        console.log("Time-series data cleared.");
    });
}

/**
 * Update potential calculation formula mode
 */
function updateFormulaMode() {
    if (formula1Radio.checked) {
        potentialFormulaMode = 1;
    } else {
        potentialFormulaMode = 2;
    }
}

/**
 * Update token distribution model mode and toggle related UI visibility
 */
function updateTokenModelMode() {
    // Update mode number based on selected radio button
    if (tokenModel1Radio.checked) tokenModelMode = 1;
    else if (tokenModel2Radio.checked) tokenModelMode = 2;
    else if (tokenModel3Radio.checked) tokenModelMode = 3;

    // Display only selected model specific parameter UI
    // Display parameter UI only for Model 2 (With Carryover)
    tokenModel2Params.style.display = (tokenModelMode === 2) ? 'flex' : 'none';
    
    // Initialize token array if simulation is not running
    if (!running) {
        initializeGlobalTokens();
    }
}

/**
 * Update cell update rule mode
 */
function updateRuleModelMode() {
    if (ruleModel1Radio.checked) {
        updateRuleMode = 1;
    } else {
        updateRuleMode = 2;
    }
}


/**
 * Get values from UI sliders and input fields, and update global parameter variables.
 * Also check and adjust consistency between parameters.
 */
function updateParameters() {
    // Get values from sliders and inputs
    w_base = parseFloat(wSlider.value);
    r1_base = parseInt(r1Slider.value);
    r2_base = parseInt(r2Slider.value);
    g_threshold_base = parseFloat(gSlider.value);
    Z_base = parseInt(zSlider.value);
    X_base = parseInt(xSlider.value);
    Y_base = parseInt(ySlider.value);
    R_survival_base = parseFloat(rSurvivalSlider.value);
    R_overcrowd_base = parseFloat(rOvercrowdSlider.value);
    carryOverRate_base = parseFloat(carryOverRateSlider.value);

    saveTimeStep = parseInt(saveTimeStepInput.value) || 0;
    imageSaveInterval = parseInt(imageSaveIntervalInput.value) || 0;


    // --- Parameter Consistency Checks ---
    // Adjust so that r1 > r2
    if (r1_base <= r2_base) {
        r2_base = r1_base - 1; if (r2_base < 1) r2_base = 1; r2Slider.value = r2_base;
    }
    
    // Adjust so that Z > Y > X
    if (Z_base <= Y_base) { Y_base = Z_base - 1; if(Y_base < 2) Y_base = 2; }
    if (Y_base <= X_base) { X_base = Y_base - 1; if(X_base < 1) X_base = 1; }
    
    // Dynamically change X, Y slider max values based on Z value
    xSlider.max = (Z_base > 2) ? Z_base - 2 : 1;
    ySlider.max = (Z_base > 1) ? Z_base - 1 : 2;
    
    // Adjust so that values do not exceed slider max
    if (X_base > parseInt(xSlider.max)) X_base = parseInt(xSlider.max);
    if (Y_base > parseInt(ySlider.max)) Y_base = parseInt(ySlider.max);
    
    // Sync slider display with values
    zSlider.value = Z_base;
    xSlider.value = X_base;
    ySlider.value = Y_base;

    // Adjust so that R_overcrowd > R_survival
    if (R_overcrowd_base <= R_survival_base) {
        R_overcrowd_base = R_survival_base + 0.01; rOvercrowdSlider.value = R_overcrowd_base;
    }

    // --- Update UI Value Displays ---
    wValue.textContent = w_base.toFixed(3);
    r1Value.textContent = r1_base;
    r2Value.textContent = r2_base;
    gValue.textContent = g_threshold_base.toFixed(2);
    zValue.textContent = Z_base;
    xValue.textContent = X_base;
    yValue.textContent = Y_base;
    rSurvivalValue.textContent = R_survival_base.toFixed(2);
    rOvercrowdValue.textContent = R_overcrowd_base.toFixed(2);
    carryOverRateValue.textContent = carryOverRate_base.toFixed(2);
    
    // If simulation is stopped, apply parameters to cell arrays and redraw
    if(!running){
        applyParameters();
        redraw();
    }
}


/*
 * -----------------------------------------------------------------------
 * ðŸš€ 3. Simulation Execution and Control
 * -----------------------------------------------------------------------
 */

/**
 * Processing when Start/Stop button is pressed
 */
function onStart(){
    if(running){
        // --- Stop Processing ---
        clearInterval(timer1); // Stop periodic execution (setInterval)
        buttonStart.value = "Start";
        running = false;
    } else {
        // --- Start Processing ---
        applyParameters(); // Commit current UI settings as parameters
        
        // Note: By not resetting timeStep even when stopping, Resuming is possible.
        // To start fresh, press Reset or Set Initial Circle.
        
        // Reset tokens only if not Model 2 (With Carryover) and it's the initial start
        // (Do not reset on resume)
        if (tokenModelMode !== 2 && timeStep === 0) {
             initializeGlobalTokens();
        }
        
        // Execute nextGeneration function every 50ms
        timer1 = setInterval(nextGeneration, 50); 
        buttonStart.value = "Stop";
        running = true;
    }
}

/**
 * Toggle view mode (Cell State / Potential)
 */
function toggleView() {
    viewMode = (viewMode === 'state') ? 'potential' : 'state';
    buttonView.value = (viewMode === 'state') ? 'View Potential' : 'View State';
    redraw(); // Redraw with current state
}

/**
 * Create 3D array [x][y][v] to store tokens
 * @param {number} fillValue - Initial value for array
 * @returns {Array} - Initialized 3D array
 */
function createTokenArray(fillValue = 0) {
    // Create [meshNum][meshNum][MAX_TOKEN_VALUE_GLOBAL] array
    return Array.from({length: meshNum}, () => 
        Array.from({length: meshNum}, () => 
            new Array(MAX_TOKEN_VALUE_GLOBAL).fill(fillValue)
        )
    );
}

/**
 * Initialize token array used globally (or between steps)
 */
function initializeGlobalTokens() {
    globalTotalTokens = createTokenArray(0);
}

/**
 * Reset canvas and cell arrays to initial state (all OFF)
 */
function initCells(){
    if(running) onStart(); // Stop if running
    
    // --- Set Canvas Size and Background Color ---
    // Calculate height for hexagonal grid
    const padding = 5;
    const gridWidth = (meshNum * cellSize) + (cellSize / 2);
    const gridHeight = ((meshNum - 1) * cellSize * Math.sqrt(3) / 2) + cellSize;
    canvas.width = gridWidth + padding * 2;
    canvas.height = gridHeight + padding * 2;
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0, canvas.width, canvas.height);

    // --- Initialize All Cell Arrays ---
    for(let i = 0; i < meshNum; i++){
        cells[i] = []; potential[i] = []; cells_w[i] = [];
        cells_r1[i] = []; cells_r2[i] = [];
        cells_x[i] = []; cells_y[i] = [];
        for(let j = 0; j < meshNum; j++){
            cells[i][j] = state_off; // Set cell state to OFF
            potential[i][j] = 0; // Set potential to 0
            
            // Calculate drawing coordinates for hexagonal grid (axial coordinates)
            // Shift x coordinate depending on whether j (y-coordinate) is odd or even
            cells_x[i][j] = padding + (j % 2) * cellSize / 2 + i * cellSize;
            cells_y[i][j] = padding + j * cellSize * Math.sqrt(3) / 2;
        }
    }
    
    initializeGlobalTokens(); // Initialize token array
    applyParameters(); // Apply parameters to cell arrays
    
    timeStep = 0; // Reset step count
    timeSeriesData = []; // Reset time-series data
    resetStatsDisplay(); // Reset stats display
    
    redraw(); // Redraw canvas
}


/*
 * -----------------------------------------------------------------------
 * ðŸŒ 4. Parameter Application and Initial Pattern
 * -----------------------------------------------------------------------
 */

/**
 * Apply global parameters (w, r1, r2) to all cells
 * (Note: r1, r2 are not used in current model but left for future extensibility)
 */
function applyParameters() {
    for(let i = 0; i < meshNum; i++){
        for(let j = 0; j < meshNum; j++){
            cells_w[i][j] = w_base;
            cells_r1[i][j] = r1_base;
            cells_r2[i][j] = r2_base;
        }
    }
}

/**
 * Place a circular initial pattern in the center
 */
function randomCells(){
    if(running) onStart(); // Stop if running
    
    const centerX = meshNum / 2;
    const centerY = meshNum / 2;
    const radius = 20; // Radius of the circle
    
    // Scan all cells and determine ON/OFF by distance from center
    for(let i = 0; i < meshNum; i++){
        for(let j = 0; j < meshNum; j++){
           const dist = Math.sqrt(Math.pow(i - centerX, 2) + Math.pow(j - centerY, 2));
           cells[i][j] = (dist <= radius) ? state_on : state_off;
           potential[i][j] = 0;
        }
    }
    
    initializeGlobalTokens();
    applyParameters();
    
    timeStep = 0;
    timeSeriesData = [];
    
    // --- Calculate and Display Initial Stats ---
    let activeCellsList = [];
    for (let i = 0; i < meshNum; i++) {
        for (let j = 0; j < meshNum; j++) {
            if (cells[i][j] === state_on) {
                activeCellsList.push({x: i, y: j});
            }
        }
    }
    calculateAndDisplayStats(activeCellsList); 
    
    redraw(); // Redraw canvas
}

// --- Drawing Related ---
var bgColor = '#000000'; // Background color (Black)
var state0Color = '#101010'; // OFF cell color (Dark Gray)
var state1Color = '#00ffff'; // ON cell color (Cyan)
var potentialNegColor = '#0000ff'; // Potential negative color (Blue)
var potentialZeroColor = '#000000'; // Potential zero color (Black)
var potentialPosColor = '#ff0000'; // Potential positive color (Red)

/**
 * Redraw the entire canvas
 */
function redraw(){
    // Fill with background color
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0, canvas.width, canvas.height);
    
    let minP = 0, maxP = 0;
    
    // If in potential display mode, calculate min/max potential
    if (viewMode === 'potential') {
        minP = Number.MAX_VALUE; maxP = Number.MIN_VALUE;
        for (let i = 0; i < meshNum; i++) {
            for (let j = 0; j < meshNum; j++) {
                if(cells[i][j] === state_on) { // Only ON cells target
                    if (potential[i][j] < minP) minP = potential[i][j];
                    if (potential[i][j] > maxP) maxP = potential[i][j];
                }
            }
        }
        // Handle edge cases where all potentials are the same
        if (minP === Number.MAX_VALUE) { minP = -1; maxP = 1; }
        else if (maxP === minP) { maxP += 1; minP -=1; }
    }
    
    // Draw all cells
    for(let x=0; x < meshNum; x++){
        for(let y=0; y < meshNum; y++){
            drawCell(x, y, minP, maxP);
        }
    }
}


/**
 * Draw a single cell
 * Modification: Changed potential display to thermography style (Blue->Green->Yellow->Red)
 * @param {number} x - Cell x coordinate
 * @param {number} y - Cell y coordinate
 * @param {number} minP - Min potential value (for potential display)
 * @param {number} maxP - Max potential value (for potential display)
 */
function drawCell(x, y, minP, maxP){
    let cellColor;
    if (viewMode === 'state') {
        // --- State Display Mode ---
        cellColor = (cells[x][y] === state_on) ? state1Color : state0Color;
    } else {
        // --- Potential Display Mode ---
        const p = potential[x][y];
        if (cells[x][y] === state_off) {
            cellColor = state0Color; // OFF cells are OFF color regardless of potential
        } else {
            // Thermography style display fix
            // Normalize potential value to 0.0 - 1.0 within minP - maxP range
            let range = maxP - minP;
            let normalized = 0.5; // Safety measure (if max == min)

            if (range !== 0) {
                normalized = (p - minP) / range;
            }
            
            // Clamp value (just in case)
            if (normalized < 0) normalized = 0;
            if (normalized > 1) normalized = 1;

            // Determine color using HSL color space
            // Hue: 240(Blue) -> 120(Green) -> 60(Yellow) -> 0(Red)
            // Formula: When normalized is 0(low) -> 240(Blue), when 1(high) -> 0(Red)
            const hue = (1.0 - normalized) * 240;
            
            // Specify color with Saturation 100%, Lightness 50%
            cellColor = `hsl(${hue}, 100%, 50%)`;
        }
    }
    
    // Draw circle (cell) with calculated color
    ctx.fillStyle = cellColor;
    ctx.beginPath();
    ctx.arc(cells_x[x][y] + cellSize/2, cells_y[x][y] + cellSize/2, cellSize/2, 0, 2*Math.PI);
    ctx.fill();
    ctx.closePath();
}

/**
 * Draw a single cell
 * @param {number} x - Cell x coordinate
 * @param {number} y - Cell y coordinate
 * @param {number} minP - Min potential value (for potential display)
 * @param {number} maxP - Max potential value (for potential display)
 */
/*function drawCell(x, y, minP, maxP){
    let cellColor;
    if (viewMode === 'state') {
        // --- State Display Mode ---
        cellColor = (cells[x][y] === state_on) ? state1Color : state0Color;
    } else {
        // --- Potential Display Mode ---
        const p = potential[x][y];
        if (cells[x][y] === state_off) {
            cellColor = state0Color; // OFF cells are OFF color regardless of potential
        } else if (p < 0) {
            // Negative value: Gradient from 0(Black) to minP(Blue)
            const factor = (minP < 0) ? (p / minP) : 0;
            cellColor = interpolateColor(potentialZeroColor, potentialNegColor, Math.min(1, factor));
        } else {
            // Positive value: Gradient from 0(Black) to maxP(Red)
            const factor = (maxP > 0) ? (p / maxP) : 0;
            cellColor = interpolateColor(potentialZeroColor, potentialPosColor, Math.min(1, factor));
        }
    }
    
    // Draw circle (cell) with calculated color
    ctx.fillStyle = cellColor;
    ctx.beginPath();
    ctx.arc(cells_x[x][y] + cellSize/2, cells_y[x][y] + cellSize/2, cellSize/2, 0, 2*Math.PI);
    ctx.fill();
    ctx.closePath();
}
*/
/*
 * -----------------------------------------------------------------------
 * ðŸ§  5. Core Simulation Logic (nextGeneration)
 * -----------------------------------------------------------------------
 * Function to advance one simulation step (generation)
 */
function nextGeneration(){
    timeStep++; // Increment time step
    
    // Array holding next generation cell states (deep copy of current state)
    let nextCells = JSON.parse(JSON.stringify(cells));
    
    // Create list of current ON cells
    var activeCells = [];
    for (let i = 0; i < meshNum; i++) {
        for (let j = 0; j < meshNum; j++) {
            if (cells[i][j] === state_on) {
                activeCells.push({x: i, y: j});
            }
            potential[i][j] = 0; // Reset potential array
        }
    }

    // If there are 0 ON cells, record stats, save, and stop
    if (activeCells.length === 0) {
        // Record all-dead state in stats (values are all 0)
        calculateAndDisplayStats([]);
        // Save data at all-dead state (results data, final image)
        saveAllData();
        
        // Stop processing
        clearInterval(timer1);
        buttonStart.value = "Start";
        running = false;
        alert("All cells have died. Simulation stopped and data saved.");
        return;
    }

    // ==========================================================
    // Token Exchange Model Branching
    // ==========================================================
    
    let totalTokens; // Final tokens held by each cell [x][y][v]
    let propagatingTokens; // Tokens propagating at each step [x][y][v]

    switch (tokenModelMode) {
        
        // --- 1) Equal Distribution (Current Model) --- (Old Model 2)
        // Features:
        // - Tokens propagate only from ON cells to ON cells
        // - Propagation calculation target restricted to activeCells for speed
        // - Every step, all ON cells generate one v=1 token
        case 1: 
            totalTokens = createTokenArray(0); // For accumulation
            propagatingTokens = createTokenArray(0); // For propagation calculation
            
            // ON cells hold one v=1 token (both for accumulation and propagation)
            activeCells.forEach(({x, y}) => {
                totalTokens[x][y][1] = 1;
                propagatingTokens[x][y][1] = 1;
            });

            for (let i = 0; i < Z_base; i++) { // Propagate for Z_base steps
                let nextPropagatingTokens = createTokenArray(0); // Tokens propagating in next step
                
                // Scan activeCells only (Senders)
                activeCells.forEach(sender => {
                    const {x, y} = sender;
                    for (let v = 1; v < MAX_TOKEN_VALUE_GLOBAL - 1; v++) {
                        if (propagatingTokens[x][y][v] > 0) {
                            const tokenCount = propagatingTokens[x][y][v];
                            const neighbors = getNeighbors(x, y); 
                            
                            neighbors.forEach(receiver => {
                                // [!] Only if receiver is ON cell (state_on)
                                if (cells[receiver.x][receiver.y] === state_on) { 
                                     // Distribute equally to 6 directions, add to v+1
                                     nextPropagatingTokens[receiver.x][receiver.y][v + 1] += tokenCount / 6;
                                }
                            });
                        }
                    }
                });
                
                // Add propagated tokens to accumulation (totalTokens)
                activeCells.forEach(cell => {
                    const {x, y} = cell;
                    for (let v = 1; v < MAX_TOKEN_VALUE_GLOBAL; v++) {
                        if (nextPropagatingTokens[x][y][v] > 0) {
                            totalTokens[x][y][v] += nextPropagatingTokens[x][y][v];
                        }
                    }
                });
                
                propagatingTokens = nextPropagatingTokens; // Move to next propagation step
            }
            break; // case 1 end


        // --- 2) Equal Distribution (With Carryover) --- (Old Model 4)
        // Features:
        // - Based on Model 1 (Current)
        // - At start of step, carry over a percentage (carryOverRate) of tokens from previous step (globalTotalTokens)
        case 2: 
            totalTokens = createTokenArray(0);
            propagatingTokens = createTokenArray(0);
            
            // Scan ON cells only
            activeCells.forEach(({x, y}) => {
                // Carry over tokens from previous step (globalTotalTokens)
                for(let v = 1; v < MAX_TOKEN_VALUE_GLOBAL; v++) {
                    const carriedOver = globalTotalTokens[x][y][v] * carryOverRate_base;
                    totalTokens[x][y][v] = carriedOver;
                    propagatingTokens[x][y][v] = carriedOver;
                }
                // Generate one new v=1 token (add to carryover)
                totalTokens[x][y][1] += 1;
                propagatingTokens[x][y][1] += 1;
            });

            // Propagation logic is same as Model 1
            for (let i = 0; i < Z_base; i++) {
                let nextPropagatingTokens = createTokenArray(0);
                activeCells.forEach(sender => {
                    const {x, y} = sender;
                    for (let v = 1; v < MAX_TOKEN_VALUE_GLOBAL - 1; v++) {
                        if (propagatingTokens[x][y][v] > 0) {
                            const tokenCount = propagatingTokens[x][y][v];
                            const neighbors = getNeighbors(x, y); 
                            neighbors.forEach(receiver => {
                                if (cells[receiver.x][receiver.y] === state_on) { 
                                     nextPropagatingTokens[receiver.x][receiver.y][v + 1] += tokenCount / 6;
                                }
                            });
                        }
                    }
                });
                activeCells.forEach(cell => {
                    const {x, y} = cell;
                    for (let v = 1; v < MAX_TOKEN_VALUE_GLOBAL; v++) {
                        if (nextPropagatingTokens[x][y][v] > 0) {
                            totalTokens[x][y][v] += nextPropagatingTokens[x][y][v];
                        }
                    }
                });
                propagatingTokens = nextPropagatingTokens;
            }
            break; // case 2 end

        // --- 3) Equal Distribution (Regeneration Study) --- (New Model)
        // Features:
        // - Basically same as Model 1 (Current)
        // - At specified step (e.g., 100), forcibly set upper half of calculation space to 0
        case 3:
            const CUT_STEP = 200; // Step count to perform cut
            
            if (timeStep === CUT_STEP) {
                // Kill upper half cells
                // (Coordinate system: j(y) is 0 at top, meshNum at bottom)
                const cutoffY = Math.floor(meshNum / 2)-10;
                
                // Need to reflect changes in activeCells and cells
                // Reconstruct activeCells list
                let remainingCells = [];
                
                for(let i=0; i<meshNum; i++){
                    for(let j=0; j<meshNum; j++){
                        if (j < cutoffY) {
                            // Upper half: Forced death
                            cells[i][j] = state_off;
                            // Need to sync nextCells as well (for subsequent logic)
                            nextCells[i][j] = state_off; 
                        }
                        
                        // Add surviving cells to list
                        if (cells[i][j] === state_on) {
                            remainingCells.push({x: i, y: j});
                        }
                    }
                }
                activeCells = remainingCells; // Update active cell list
            }
            
            // Below is same calculation process as Model 1
            totalTokens = createTokenArray(0);
            propagatingTokens = createTokenArray(0);
            
            activeCells.forEach(({x, y}) => {
                totalTokens[x][y][1] = 1;
                propagatingTokens[x][y][1] = 1;
            });

            for (let i = 0; i < Z_base; i++) {
                let nextPropagatingTokens = createTokenArray(0);
                activeCells.forEach(sender => {
                    const {x, y} = sender;
                    for (let v = 1; v < MAX_TOKEN_VALUE_GLOBAL - 1; v++) {
                        if (propagatingTokens[x][y][v] > 0) {
                            const tokenCount = propagatingTokens[x][y][v];
                            const neighbors = getNeighbors(x, y); 
                            neighbors.forEach(receiver => {
                                if (cells[receiver.x][receiver.y] === state_on) { 
                                     nextPropagatingTokens[receiver.x][receiver.y][v + 1] += tokenCount / 6;
                                }
                            });
                        }
                    }
                });
                activeCells.forEach(cell => {
                    const {x, y} = cell;
                    for (let v = 1; v < MAX_TOKEN_VALUE_GLOBAL; v++) {
                        if (nextPropagatingTokens[x][y][v] > 0) {
                            totalTokens[x][y][v] += nextPropagatingTokens[x][y][v];
                        }
                    }
                });
                propagatingTokens = nextPropagatingTokens;
            }
            break; // case 3 end

    } // switch (tokenModelMode) end

    // ==========================================================
    // Potential Calculation (Common to All Models)
    // ==========================================================
    // Calculate potential using accumulated totalTokens
    
    activeCells.forEach(cell => {
        const {x, y} = cell;
        const tokens = totalTokens[x][y]; 
        if (!tokens) return; // Skip if cell has no tokens (rarely happens)

        let sum_X = 0; // Sum of tokens in range X (1~X_base)
        let sum_Y = 0; // Sum of tokens in range Y (1~Y_base)

        // Sum from v=1 to X_base
        for (let v = 1; v <= X_base && v < MAX_TOKEN_VALUE_GLOBAL; v++) { 
            sum_X += tokens[v]; 
        }
        // Sum from v=1 to Y_base
        for (let v = 1; v <= Y_base && v < MAX_TOKEN_VALUE_GLOBAL; v++) { 
            sum_Y += tokens[v]; 
        }
        
        // Determine potential based on selected formula
        if (potentialFormulaMode === 1) {
            // Formula 1: P = (1~X) - (1~Y) * w
            potential[x][y] = sum_X - (sum_Y * cells_w[x][y]);
        } else { 
            // Formula 2: P = (1~Y) - (1~X) * w
            potential[x][y] = sum_Y - (sum_X * cells_w[x][y]);
        }
    });

    // If Model 2 (With Carryover), save calculation result (totalTokens) for next step
    if (tokenModelMode === 2) {
        globalTotalTokens = totalTokens;
    }
    
    // ==========================================================
    // Calculate and Display Stats
    // ==========================================================
    calculateAndDisplayStats(activeCells);
    
    
    // ==========================================================
    // Survival, Growth, Regression Processing
    // ==========================================================
    // Determine next generation cell state (nextCells) based on potential value

    if (updateRuleMode === 1) {
        // --- Rule 1: Boundary Only ---
        // Only boundary cells (ON cells with OFF neighbor) are update targets
        
        const boundaryCells = [];
        activeCells.forEach(cell => {
            if (isBoundary(cell.x, cell.y, cells)) { 
                boundaryCells.push(cell);
            }
        });

        const growthParentCandidates = []; // Candidates for growth source cells
        const claimedSpots = new Set(); // Keys of cells reserved as growth targets ("x,y")

        // 1. Regression Processing (Boundary cells only)
        boundaryCells.forEach(cell => {
            const { x, y } = cell;
            const p = potential[x][y];
            
            // Die if below survival threshold (R_survival) or above overcrowding threshold (R_overcrowd)
            if (p <= R_survival_base || p >= R_overcrowd_base) {
                nextCells[x][y] = state_off; 
                potential[x][y] = 0; // Reset potential of dead cell
            }
            // Candidate for growth if above growth threshold (g_threshold)
            else if (p >= g_threshold_base) {
                growthParentCandidates.push({ x, y });
            }
        });

        // 2. Growth Processing (With conflict resolution)
        shuffleArray(growthParentCandidates); // Randomize growth order (for fairness in conflict)
        
        growthParentCandidates.forEach(parent => {
            // Find growable neighbor OFF cells (judged based on nextCells)
            let emptyNeighbors = getNeighbors(parent.x, parent.y).filter(n => nextCells[n.x][n.y] === state_off);
            
            if (emptyNeighbors.length > 0) {
                shuffleArray(emptyNeighbors); // Randomize growth direction
                
                for (const target of emptyNeighbors) {
                    const key = `${target.x},${target.y}`;
                    // Check if already reserved (claimed) by another cell
                    if (!claimedSpots.has(key)) {
                        nextCells[target.x][target.y] = state_on; // Turn cell ON
                        claimedSpots.add(key); // Mark as reserved
                        break; // One parent grows only one cell
                    }
                }
            }
        });

    } else {
        // --- Rule 2: Internal & Boundary ---
        // Internal cells are also targets for regression processing
        
        // 1. Regression Processing (All active cells)
        activeCells.forEach(cell => {
            const { x, y } = cell;
            const p = potential[x][y];
            
            // Die if below survival threshold or above overcrowding threshold (Including internal cells)
            if (p <= R_survival_base || p >= R_overcrowd_base) {
                nextCells[x][y] = state_off;
                potential[x][y] = 0; 
            }
        });

        // 2. Growth Processing (Growth source is boundary cells only)
        const growthParentCandidates = [];
        activeCells.forEach(cell => {
            const { x, y } = cell;
            // Still alive after regression processing (nextCells === state_on)?
            if (nextCells[x][y] === state_on) { 
                // Is it a boundary cell (in regression processed state)?
                if (isBoundary(x, y, nextCells)) { 
                    // Above growth threshold?
                    if (potential[x][y] >= g_threshold_base) {
                        growthParentCandidates.push({ x, y });
                    }
                }
            }
        });
        
        // Conflict resolution logic is same as Rule 1
        shuffleArray(growthParentCandidates);
        const claimedSpots = new Set(); 

        growthParentCandidates.forEach(parent => {
            let emptyNeighbors = getNeighbors(parent.x, parent.y).filter(n => nextCells[n.x][n.y] === state_off);
            if (emptyNeighbors.length > 0) {
                shuffleArray(emptyNeighbors);
                for (const target of emptyNeighbors) {
                    const key = `${target.x},${target.y}`;
                    if (!claimedSpots.has(key)) {
                        nextCells[target.x][target.y] = state_on;
                        claimedSpots.add(key);
                        break;
                    }
                }
            }
        });
    } // updateRuleMode branch end

    // Reflect next generation state (nextCells) to current state (cells)
    cells = nextCells;
    redraw(); // Redraw canvas
    
    // ==========================================================
    // Check Data Save Conditions
    // ==========================================================
    checkDataSaveConditions();
}

/*
 * -----------------------------------------------------------------------
 * ðŸ“Š 6. Stats Calculation and Display Functions
 * -----------------------------------------------------------------------
 */

/**
 * Reset all numbers in stats display area to 0
 */
function resetStatsDisplay() {
    statsTimeStepEl.textContent = '0';
    statsActiveCellsEl.textContent = '0';
    statsBoundaryCellsEl.textContent = '0';
    statsPotentialAvgEl.textContent = '0.000';
    statsPotentialMaxEl.textContent = '0.000';
    statsPotentialMinEl.textContent = '0.000';
    statsCircularityEl.textContent = '0.000';
    statsDispersionEl.textContent = '0.000';
}

/**
 * Calculate various stats from current cell state and display on screen
 * @param {Array} activeCellsList - List of current ON cells {x, y}
 */
function calculateAndDisplayStats(activeCellsList) {
    const activeCellCount = activeCellsList.length;

    // If ON cells are 0
    if (activeCellCount === 0) {
        resetStatsDisplay();
        statsTimeStepEl.textContent = timeStep; // Maintain step count display
        if (running) { // Record "0" data if running
             timeSeriesData.push({
                timeStep: timeStep,
                activeCellCount: 0,
                boundaryCellCount: 0,
                potentialAvg: 0,
                potentialMax: 0,
                potentialMin: 0,
                circularity: 0,
                dispersion: 0
            });
        }
        return;
    }

    // --- Stats Calculation Variables ---
    let potSum = 0; // Potential sum
    let potMin = Infinity; // Potential min
    let potMax = -Infinity; // Potential max
    let boundaryCellCount = 0; // Boundary cell count
    let centroidX = 0; // Centroid X (drawing coordinate base)
    let centroidY = 0; // Centroid Y (drawing coordinate base)
    
    activeCellsList.forEach(cell => {
        const p = potential[cell.x][cell.y];
        
        // Potential Stats
        potSum += p;
        if (p < potMin) potMin = p;
        if (p > potMax) potMax = p;
        
        // Boundary Check
        if (isBoundary(cell.x, cell.y, cells)) {
            boundaryCellCount++;
        }
        
        // For Centroid Calculation
        centroidX += cells_x[cell.x][cell.y]; // Sum drawing coordinates
        centroidY += cells_y[cell.x][cell.y];
    });

    // --- Average, Max, Min ---
    const potentialAvg = potSum / activeCellCount;
    const potentialMax = potMax === -Infinity ? 0 : potMax;
    const potentialMin = potMin === Infinity ? 0 : potMin;
    
    // --- Centroid ---
    centroidX /= activeCellCount;
    centroidY /= activeCellCount;
    
    // --- Morphology (Area, Perimeter, Circularity) ---
    const area = activeCellCount; // Area = ON cell count
    const perimeter = boundaryCellCount; // Perimeter = Boundary cell count
    // Circularity (Approaches 1.0 for perfect circle)
    const circularity = (perimeter > 0) ? (4 * Math.PI * area) / (perimeter * perimeter) : (area > 0 ? 1.0 : 0.0);

    // --- Dispersion ---
    // Average distance from centroid to each cell
    let dispersionSum = 0;
    activeCellsList.forEach(cell => {
        const dx = cells_x[cell.x][cell.y] - centroidX;
        const dy = cells_y[cell.x][cell.y] - centroidY;
        dispersionSum += Math.sqrt(dx * dx + dy * dy);
    });
    const dispersion = dispersionSum / activeCellCount;
    
    // --- Reflect Calculation Results to HTML Elements ---
    statsTimeStepEl.textContent = timeStep;
    statsActiveCellsEl.textContent = activeCellCount;
    statsBoundaryCellsEl.textContent = boundaryCellCount;
    statsPotentialAvgEl.textContent = potentialAvg.toFixed(3);
    statsPotentialMaxEl.textContent = potentialMax.toFixed(3);
    statsPotentialMinEl.textContent = potentialMin.toFixed(3);
    statsCircularityEl.textContent = circularity.toFixed(3);
    statsDispersionEl.textContent = dispersion.toFixed(3);
    
    // --- Save to Time Series Data Array ---
    timeSeriesData.push({
        timeStep: timeStep,
        activeCellCount: activeCellCount,
        boundaryCellCount: boundaryCellCount,
        potentialAvg: parseFloat(potentialAvg.toFixed(4)),
        potentialMax: parseFloat(potentialMax.toFixed(4)),
        potentialMin: parseFloat(potentialMin.toFixed(4)),
        circularity: parseFloat(circularity.toFixed(4)),
        dispersion: parseFloat(dispersion.toFixed(4))
    });
}


/*
 * -----------------------------------------------------------------------
 * ðŸ’¾ 7. Data Saving Functions
 * -----------------------------------------------------------------------
 */

/**
 * Check data save timing (step count) and call save function if condition met
 */
function checkDataSaveConditions() {
    // --- Periodic Image Save ---
    // Is imageSaveInterval greater than 0 and current step a multiple of it?
    if (imageSaveInterval > 0 && timeStep % imageSaveInterval === 0) {
        saveCanvasAsImage(`simulation_step_${timeStep}.png`);
    }

    // --- Final Data Save ---
    // Is saveTimeStep greater than 0 and current step reached it?
    if (saveTimeStep > 0 && timeStep === saveTimeStep) {
        console.log(`Reached save step ${saveTimeStep}. Saving data...`);
        saveAllData(); // Save CSV, TXT, PNG all
        
        // Stop simulation when save is complete
        if(running) {
            onStart();
        }
    }
}

/**
 * Save all data (Time-series CSV, Parameter TXT, Final Image PNG)
 * Change: Save potential value image as well
 */
function saveAllData() {
    saveTimeSeriesCSV();
    saveParametersSummary();
    
    // Save State Image
    // Temporarily switch ViewMode to State and draw
    const originalViewMode = viewMode;
    viewMode = 'state';
    redraw();
    saveCanvasAsImage(`simulation_final_step_${timeStep}_state.png`);
    
    // Save Potential Image
    // Switch ViewMode to Potential and draw
    viewMode = 'potential';
    redraw();
    saveCanvasAsImage(`simulation_final_step_${timeStep}_potential.png`);
    
    // Revert ViewMode
    viewMode = originalViewMode;
    redraw();
}

/**
 * Helper function to trigger file download
 * @param {string} content - File content
 * @param {string} fileName - Filename for download
 * @param {string} mimeType - File MIME type (e.g., "data:text/csv;charset=utf-8,")
 */
function downloadFile(content, fileName, mimeType) {
    try {
        // URI encode content
        const encodedUri = encodeURI(mimeType + content);
        // Create invisible <a> (link) element
        const link = document.createElement('a');
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", fileName);
        document.body.appendChild(link); // Add to page
        link.click(); // Programmatically click to start download
        document.body.removeChild(link); // Remove from page
        console.log(`Successfully triggered download for: ${fileName}`);
    } catch (e) {
        console.error(`Failed to download ${fileName}: `, e);
    }
}

/**
 * Save time-series data (timeSeriesData) as CSV file
 */
function saveTimeSeriesCSV() {
    if (timeSeriesData.length === 0) {
        console.warn("No time-series data to save.");
        return;
    }
    
    try {
        const headers = Object.keys(timeSeriesData[0]); // Header row (timeStep, activeCellCount, ...)
        let csvContent = "";
        csvContent += headers.join(",") + "\r\n"; // Add header to CSV
        
        // Add data rows
        timeSeriesData.forEach(row => {
            const values = headers.map(header => row[header]);
            csvContent += values.join(",") + "\r\n";
        });
        
        // Download as CSV file
        downloadFile(csvContent, `simulation_timeseries_step_${timeStep}.csv`, "data:text/csv;charset=utf-8,");
        
    } catch (e) {
        console.error("Error generating CSV content: ", e);
    }
}

/**
 * Save current simulation parameters as text file
 */
function saveParametersSummary() {
    try {
        // Summarize parameters to save in an object
        const params = {
            "SaveTime": new Date().toISOString(),
            "FinalTimeStep": timeStep,
            "MeshSize": meshNum,
            "CellSize": cellSize,
            
            "TokenModelMode": tokenModelMode,
            "UpdateRuleMode": updateRuleMode,
            "PotentialFormulaMode": potentialFormulaMode,
            
            "Z_TokenSteps": Z_base,
            "X_Range": X_base,
            "Y_Range": Y_base,
            "w_Weight": w_base,
            "G_GrowthThreshold": g_threshold_base,
            "R_SurvivalThreshold": R_survival_base,
            "R_OvercrowdThreshold": R_overcrowd_base,
            
            "Model2_CarryOverRate": carryOverRate_base,
            
            "r1_Outer (Unused)": r1_base,
            "r2_Inner (Unused)": r2_base
        };

        let summaryContent = "Simulation Parameters Summary\r\n";
        summaryContent += "=================================\r\n";
        
        // Add to text in "Key: Value" format
        for (const [key, value] of Object.entries(params)) {
            summaryContent += `${key}: ${value}\r\n`;
        }
        
        // Download as text file
        downloadFile(summaryContent, `simulation_summary_step_${timeStep}.txt`, "data:text/plain;charset=utf-8,");

    } catch (e) {
        console.error("Error generating parameters summary: ", e);
    }
}

/**
 * Save current canvas state as PNG image file
 * @param {string} fileName - Filename for download
 */
function saveCanvasAsImage(fileName) {
    try {
        const dataURL = canvas.toDataURL('image/png'); // Convert canvas to PNG Data URL
        // Download using <a> element
        const link = document.createElement('a');
        link.download = fileName;
        link.href = dataURL;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        console.log(`Successfully triggered image download: ${fileName}`);
    } catch (e) {
        console.error(`Failed to save canvas image ${fileName}: `, e);
    }
}

/*
 * -----------------------------------------------------------------------
 * ðŸ› ï¸ 8. Existing Helper Functions (Utilities)
 * -----------------------------------------------------------------------
 */

/**
 * Get 6 neighbors of specified cell in hexagonal grid (axial coordinates)
 * Supports periodic boundary (torus).
 * @param {number} x - Cell x coordinate
 * @param {number} y - Cell y coordinate
 * @returns {Array} - Array of neighbor cell {x, y} objects
 */
function getNeighbors(x, y) {
    let neighbors = [];
    const isOddRow = y % 2 !== 0; // Odd row (y=1, 3, 5...)?
    
    // Relative coordinates of neighbors differ for odd and even rows
    const neighbor_coords = isOddRow ? 
        [ {dx:1, dy:0}, {dx:-1, dy:0}, {dx:0, dy:-1}, {dx:1, dy:-1}, {dx:0, dy:1}, {dx:1, dy:1} ] :
        [ {dx:1, dy:0}, {dx:-1, dy:0}, {dx:-1, dy:-1}, {dx:0, dy:-1}, {dx:-1, dy:1}, {dx:0, dy:1} ];
    
    neighbor_coords.forEach(c => {
        // If (x + dx) goes out of grid range, wrap around from opposite side (% meshNum)
        let nx = (x + c.dx + meshNum) % meshNum;
        let ny = (y + c.dy + meshNum) % meshNum;
        neighbors.push({x: nx, y: ny});
    });
    return neighbors;
}

/**
 * Determine if specified cell is a "Boundary Cell"
 * (Is an ON cell, and at least one of its 6 neighbors is an OFF cell)
 * @param {number} x - Cell x coordinate
 * @param {number} y - Cell y coordinate
 * @param {Array} grid - Cell state grid used for judgment (usually `cells`)
 * @returns {boolean} - true if boundary cell
 */
function isBoundary(x, y, grid) {
    const neighbors = getNeighbors(x, y);
    for (const n of neighbors) {
        if (grid[n.x][n.y] === state_off) { // If there is at least one OFF neighbor
            return true;
        }
    }
    return false; // All neighbors are ON
}

/**
 * Randomly shuffle array elements (Fisher-Yates algorithm)
 * @param {Array} array - Array to shuffle (destructively modified)
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

/**
 * Processing when canvas is clicked
 * (Valid only when simulation is stopped)
 * @param {Event} e - Click event object
 */
function canvasClick(e) {
    if (running) return; // Ignore if running
    
    // Convert click coordinates to canvas local coordinates
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Find nearest cell
    for (let i = 0; i < meshNum; i++) {
        for (let j = 0; j < meshNum; j++) {
            // Calculate distance to cell center
            const dx = mouseX - (cells_x[i][j] + cellSize / 2);
            const dy = mouseY - (cells_y[i][j] + cellSize / 2);
            if (Math.sqrt(dx * dx + dy * dy) < cellSize / 2) {
                // Clicked cell found
                
                // Toggle cell state (ON <-> OFF)
                cells[i][j] = (cells[i][j] === state_on) ? state_off : state_on;
                
                // --- Reset State ---
                // (Since cell configuration changed, reset stats and potential calculation)
                timeStep = 0;
                timeSeriesData = [];
                let activeCellsList = [];
                for (let r = 0; r < meshNum; r++) {
                    for (let c = 0; c < meshNum; c++) {
                        potential[r][c] = 0; // Reset potential
                        if (cells[r][c] === state_on) {
                            activeCellsList.push({x: r, y: c});
                        }
                    }
                }
                initializeGlobalTokens(); // Reset tokens too
                calculateAndDisplayStats(activeCellsList); // Recalculate stats
                
                // Redraw only clicked cell (Optimization)
                drawCell(i, j, 0, 1);
                return; // Exit loop if cell found
            }
        }
    }
}

/**
 * Linear interpolate between two hex color codes
 * @param {string} hex1 - Start color (e.g., '#000000')
 * @param {string} hex2 - End color (e.g., '#ff0000')
 * @param {number} factor - Interpolation factor (0.0 - 1.0)
 * @returns {string} - Interpolated color RGB string (e.g., 'rgb(128, 0, 0)')
 */
function interpolateColor(hex1, hex2, factor) {
    // Convert hex to R, G, B values
    const r1 = parseInt(hex1.substring(1, 3), 16), g1 = parseInt(hex1.substring(3, 5), 16), b1 = parseInt(hex1.substring(5, 7), 16);
    const r2 = parseInt(hex2.substring(1, 3), 16), g2 = parseInt(hex2.substring(3, 5), 16), b2 = parseInt(hex2.substring(5, 7), 16);
    // Linear interpolate using factor
    const r = Math.round(r1 + factor * (r2 - r1)), g = Math.round(g1 + factor * (g2 - g1)), b = Math.round(b1 + factor * (b2 - b1));
    return `rgb(${r}, ${g}, ${b})`;
}

</script>

</body>
</html>